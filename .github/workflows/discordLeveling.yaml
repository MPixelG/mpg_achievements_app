name: Discord Leveling
on:
  push:
    branches: [main]

jobs:
  run_command:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: get stats
        id: stats
        run: |
          echo "=== DEBUG: GitHub Context ===" >&2
          echo "GITHUB_SHA: $GITHUB_SHA" >&2
          echo "GITHUB_BEFORE: ${{ github.event.before }}" >&2
          echo "GITHUB_AFTER: ${{ github.event.after }}" >&2

          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.event.after }}"

          if [[ "$BEFORE" =~ ^0+$ ]]; then
            echo "Neuer Branch erkannt, nutze nur HEAD" >&2
            range=$(git rev-parse HEAD)
          else
            range=$(git log --format=%H $BEFORE..$AFTER 2>/dev/null)
            if [ -z "$range" ]; then
              echo "Keine Commits gefunden, nutze HEAD" >&2
              range=$(git rev-parse HEAD)
            fi
          fi

          echo "=== Commits in range ===" >&2
          echo "$range" >&2
          echo "=== Count: $(echo "$range" | wc -l) ===" >&2

          for sha in $range; do
            parent_count=$(git rev-list --count --parents -n1 $sha | awk '{print NF-1}')
            if [ "$parent_count" -gt 1 ]; then
              echo "Merge-Commit erkannt ($sha), Workflow wird Ã¼bersprungen."
            fi
          done

          total_added=0
          total_deleted=0
          all_msgs=""
          author_name=""
          author_email=""

          for sha in $range; do
            echo "=== Processing commit: $sha ===" >&2
            added=$(git show --numstat --pretty="" "$sha" | awk '$1 ~ /^[0-9]+$/ {sum += $1} END {print sum+0}')
            deleted=$(git show --numstat --pretty="" "$sha" | awk '$2 ~ /^[0-9]+$/ {sum += $2} END {print sum+0}')
            msg=$(git log -1 --pretty=format:'%B' "$sha" | tr -d '\000-\010\013\014\016-\037')

            echo "Added: $added, Deleted: $deleted" >&2

            total_added=$((total_added + added))
            total_deleted=$((total_deleted + deleted))

            if [ -z "$all_msgs" ]; then
              all_msgs="$msg"
            else
              all_msgs="${all_msgs}
          ${msg}"
          fi
          
          if [ -z "$author_name" ]; then
          author_name=$(git log -1 --pretty=format:'%an' "$sha")
          author_email=$(git log -1 --pretty=format:'%ae' "$sha")
          fi
          done
          
          echo "=== FINAL TOTALS ===" >&2
          echo "Total added: $total_added" >&2
          echo "Total deleted: $total_deleted" >&2
          
          echo "COMMIT_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV
          echo "AUTHOR_NAME=$author_name" >> $GITHUB_ENV
          echo "AUTHOR_EMAIL=$author_email" >> $GITHUB_ENV
          echo "ADDITIONS=$total_added" >> $GITHUB_ENV
          echo "DELETIONS=$total_deleted" >> $GITHUB_ENV
          echo "COMMIT_MESSAGE<<EOF" >> $GITHUB_ENV
          echo "$all_msgs" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV


      - name: map username
        id: map
        env:
          REPO: ${{ github.repository }}
          SHA: ${{ env.COMMIT_SHA }}
          AUTHOR_EMAIL: ${{ env.AUTHOR_EMAIL }}
        run: |
          # Try to get GitHub user login via GitHub API commit object (more reliable when GitHub linked the commit)
          api_url="https://api.github.com/repos/$REPO/commits/$SHA"
          echo "Querying $api_url" >&2

          commit_json=$(curl -s -H "Accept: application/vnd.github+json" "$api_url")
          login=$(echo "$commit_json" | jq -r '.author.login // empty')
          if [ -n "$login" ]; then
            echo "FOUND_LOGIN=$login" >> $GITHUB_ENV
            echo "mapped: $login" >&2
            exit 0
          fi

          # If not found, try to search commits in the repo by author email (may require token for rate limits)
          if [ -n "$AUTHOR_EMAIL" ] && [ "$AUTHOR_EMAIL" != "null" ]; then
            # Search commits endpoint requires authentication for many queries; try unauthenticated first
            search_url="https://api.github.com/search/commits?q=repo:$REPO+author:$AUTHOR_EMAIL"
            search_json=$(curl -s -H "Accept: application/vnd.github.cloak-preview" "$search_url")
            found_login=$(echo "$search_json" | jq -r '.items[0].author.login // empty')
            if [ -n "$found_login" ]; then
              echo "FOUND_LOGIN=$found_login" >> $GITHUB_ENV
              echo "mapped by search: $found_login" >&2
              exit 0
            fi
          fi
          # Fallback: use git author name
          git_author=$(git log -1 --pretty=format:'%an')
          echo "FOUND_LOGIN=$git_author" >> $GITHUB_ENV
          echo "fallback to author name: $git_author" >&2

      - name: Send message via bot
        env:
          BOT_TOKEN: ${{ secrets.DISCHORD_BOT_TOKEN }}
          CHANNEL_ID: '1417079982848479343'
          AUTHOR: ${{ env.FOUND_LOGIN }}
          ADDITIONS: ${{ env.ADDITIONS }}
          DELETIONS: ${{ env.DELETIONS }}
          MESSAGE: ${{ env.COMMIT_MESSAGE }}
        run: |
          escape_keep_newlines() {
            local raw="$1"
            local out=""
            local i=0
            local len=${#raw}
            while [ $i -lt $len ]; do
              ch="${raw:$i:1}"
              case "$ch" in
                [a-zA-Z0-9\ \_\-\'\":\/\.])
                  out+="$ch"
          
                  ;;
                $'\n')
                  out+=$'\n'
                  ;;
                *)
              if [ "$ch" = '\' ]; then
                out="${out}\\\\"
              else
                if [ "$ch" = '#' ]; then
                  out="${out} "
              else
                out="${out}\\${ch}"
              fi
              fi

              esac
              i=$((i+1))
            done
            printf '%s' "$out"
          }

          # sanitize MESSAGE and AUTHOR preserving real newlines
          sanitized_msg=$(escape_keep_newlines "$MESSAGE")
          sanitized_author=$(escape_keep_newlines "$AUTHOR")

          content="New commit by ${sanitized_author} ${ADDITIONS} ${DELETIONS}"

          # Build JSON with jq; supply description with actual newlines preserved
          payload=$(jq -nc --arg content "$content" --arg description "$sanitized_msg" '{content:$content, description:$description}')

          curl -s -X POST "https://atlas.bot/api/guilds/1417072674219229307/actions/05652f94-93cf-4515-a2cd-73f1cabe0162/webhook/07b5213c6bac954da52a57918d9b32110b028dd647e51c8536bd5cfcefd6f6c7" \
            -H "Authorization: Bot $BOT_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$payload" --ssl-no-revoke || echo "curl failed" >&2
